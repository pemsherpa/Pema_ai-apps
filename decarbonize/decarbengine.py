# -*- coding: utf-8 -*-
"""DecarbEngine.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EWIicIg05wODK4aX-Dk-DY5WdoQz968r
"""

from google.colab import drive
drive.mount('/content/drive')

google_maps_api_key = "AIzaSyD1fbsNKLIWwHly5YcSBcuMWhYd2kTIN08"
flight_api_key = '7b97097f97bcea06b3c9c8b81e864da1f686069cdfba1dfd89834eec702b8f16'
oil_price_api = 'jDLAcmPbuXd1CMXRjKFZMliukSgC6ujhUjnKaxOf'

import pandas as pd
import matplotlib.pyplot as plt
import re
import seaborn as sns
import numpy as np
import requests
from geopy.distance import geodesic
import time
from itertools import permutations
from scipy.stats import zscore

from datetime import datetime
from enum import Enum





#flights

origin = "LAX"
destination = "JFK"
departure_date = "2024-07-01"
return_date = "2024-07-03"
firm = '2107 Addison St, Berkeley, CA'

weights = DecarbWeight(0.4,0.3,0.2,0.1)
flight = FlightDataAnalyzer(flight_api_key, weights,origin, destination, departure_date, return_date)

flight.get_return_tickets()

class FlightDataAnalyzer:
    def __init__(self, api_key, weights,origin, destination, departure_date, return_date=None):
        self.api = api_key
        self.origin = origin
        self.destination = destination
        self.departure_date = departure_date
        self.return_date = return_date
        self.weights = weights

        self.flights_economy = self.search_flights_serpapi(origin, destination, departure_date, '1', return_date)
        self.flights_premium_economy = self.search_flights_serpapi(origin, destination, departure_date, '2', return_date)
        self.flights_business = self.search_flights_serpapi(origin, destination, departure_date, '3', return_date)
        self.flights_first_class = self.search_flights_serpapi(origin, destination, departure_date, '4', return_date)

        self.df_economy = self.create_dataframes_serpapi(self.flights_economy)
        self.df_premium_economy = self.create_dataframes_serpapi(self.flights_premium_economy)
        self.df_business = self.create_dataframes_serpapi(self.flights_business)
        self.df_first_class = self.create_dataframes_serpapi(self.flights_first_class)

        self.df_all_flights = pd.concat([self.df_economy, self.df_business, self.df_first_class, self.df_premium_economy], ignore_index=True)

        self.df_all_flights['Departure Time'] = pd.to_datetime(self.df_all_flights['Departure Time'])
        self.df_all_flights['Arrival Time'] = pd.to_datetime(self.df_all_flights['Arrival Time'])


    def get_optimal_flight(self, df_all_flights):


        df_all_flights['Price Z-Score'] = (df_all_flights['Price'] - df_all_flights['Price'].mean()) / df_all_flights['Price'].std()

        df_all_flights['Duration Z-Score'] = (df_all_flights['Duration'] - df_all_flights['Duration'].mean()) / df_all_flights['Duration'].std()
        df_all_flights['Stops Z-Score'] = (df_all_flights['Stops'] - df_all_flights['Stops'].mean()) / df_all_flights['Stops'].std()
        df_all_flights['Carbon Emissions Z-Score'] = (df_all_flights['Carbon Emissions'] - df_all_flights['Carbon Emissions'].mean() )/ df_all_flights['Carbon Emissions'].std()

        df_all_flights['Weighted Score'] = (
            self.weights.price_weight * df_all_flights['Price Z-Score'] +
            self.weights.duration_weight * df_all_flights['Duration Z-Score'] +
            self.weights.stop_weight * df_all_flights['Stops Z-Score'] +
            self.weights.carbon_weight * df_all_flights['Carbon Emissions Z-Score']
        )

        df_all_flights['Rank'] = df_all_flights['Weighted Score'].rank()
        df_best_trade_off_flights = df_all_flights.sort_values(by='Rank').head(1)
        return df_best_trade_off_flights

    def get_return_tickets(self):

        temp  = self.get_optimal_flight(self.df_all_flights)
        self.dep_token = temp['token'].iloc[0]

        return_flights_economy = self.search_flights_serpapi(self.origin, self.destination, self.departure_date, '1', self.return_date, token=self.dep_token)
        return_flights_premium_economy = self.search_flights_serpapi(self.origin, self.destination, self.departure_date, '2', self.return_date, token=self.dep_token)
        return_flights_business = self.search_flights_serpapi(self.origin, self.destination, self.departure_date, '3', self.return_date, token=self.dep_token)
        return_flights_first_class = self.search_flights_serpapi(self.origin, self.destination, self.departure_date, '4', self.return_date, token=self.dep_token)

        df_return_flights_economy = self.create_dataframes_serpapi(return_flights_economy)
        df_return_flights_premium_economy = self.create_dataframes_serpapi(return_flights_premium_economy)
        df_return_flights_business = self.create_dataframes_serpapi(return_flights_business)
        df_return_flights_first_class = self.create_dataframes_serpapi(return_flights_first_class)

        all_return_flights = pd.concat([df_return_flights_economy, df_return_flights_business, df_return_flights_first_class, df_return_flights_premium_economy], ignore_index=True)
        return self.get_optimal_flight(all_return_flights)

    def create_dataframes_serpapi(self, flights):
        columns = ['Carrier', 'Flight Number', 'Departure Airport', 'Departure Time', 'Arrival Airport', 'Arrival Time', 'Duration',
                   'Aircraft', 'Carbon Emissions', 'Typical Carbon Emissions', 'Difference in Percent', 'Travel Class',
                   'Price', 'Stops', 'Layovers', 'Total Duration','token']
        flight_data = []
        seen_flights = set()

        def extract_flight_data(flight_list):
            for flight in flight_list:
                price = flight['price']
                stops = len(flight['flights']) - 1
                layovers = flight.get('layovers', 'N/A')
                total_duration = flight['total_duration']
                if 'departure_token' in flight:
                    token = flight['departure_token']
                else:
                    token = 'N/A'

                for i, segment in enumerate(flight['flights']):
                    carrier_code = segment['airline']
                    flight_number = segment['flight_number']
                    departure = segment['departure_airport']['id']
                    departure_time = segment['departure_airport']['time']
                    arrival = segment['arrival_airport']['id']
                    arrival_time = segment['arrival_airport']['time']
                    duration = segment['duration']
                    aircraft = segment['airplane']

                    carbon_emissions = flight['carbon_emissions']['this_flight']
                    if flight['carbon_emissions']['typical_for_this_route']:
                        typical_carbon_emissions = flight['carbon_emissions']['typical_for_this_route']
                        difference_in_percent = flight['carbon_emissions']['difference_percent']
                    else:
                         typical_carbon_emissions = 'N/A'
                         difference_in_percent = 'N/A'



                    travel_class_name = segment['travel_class']

                    flight_key = (carrier_code, flight_number, departure_time, arrival_time)
                    if flight_key not in seen_flights:
                        seen_flights.add(flight_key)
                        flight_data.append([
                            carrier_code, flight_number, departure, departure_time,
                            arrival, arrival_time, duration, aircraft, carbon_emissions, typical_carbon_emissions, difference_in_percent, travel_class_name,
                            price, stops, layovers, total_duration,token
                        ])

        if 'best_flights' in flights:
            extract_flight_data(flights['best_flights'])

        if 'other_flights' in flights:
            extract_flight_data(flights['other_flights'])

        df_flights = pd.DataFrame(flight_data, columns=columns)
        return df_flights

    def price_insights(self):
        lst_economy = self.flights_economy['price_insights']['price_history']

        lst_business = self.flights_business['price_insights']['price_history']

        temp_df_economy = pd.DataFrame(lst_economy, columns=['time', 'price'])
        temp_df_economy['time'] = temp_df_economy['time'].apply(datetime.fromtimestamp)

        temp_df_business = pd.DataFrame(lst_business, columns=['time', 'price'])
        temp_df_business['time'] = temp_df_business['time'].apply(datetime.fromtimestamp)

       # temp_df_first_class = pd.DataFrame(lst_first_class, columns=['time', 'price'])
        #temp_df_first_class['time'] = temp_df_first_class['time'].apply(datetime.fromtimestamp)

        graph_economy = temp_df_economy.plot.line(x='time', y='price')
       # graph_premium_economy = temp_df_premium.plot.line(x='time', y='price')
        graph_business = temp_df_business.plot.line(x='time', y='price')
       # graph_first_class = temp_df_first_class.plot.line(x='time', y='price')

        info_economy = self.flights_economy['price_insights']['price_history'][:-1]
       # info_premium_economy = self.flights_premium_economy['price_insights']['price_history'][:-1]
        info_business = self.flights_business['price_insights']['price_history'][:-1]
        #info_first_class = self.flights_first_class['price_insights']['price_history'][:-1]

        return info_economy, info_business, graph_economy,  graph_business

    def search_flights_serpapi(self, origin, destination, departure_date, travel_class, return_date=None, token=None):
        url = "https://serpapi.com/search"
        params = {
            "engine": "google_flights",
            "q": f"flights from {origin} to {destination} on {departure_date}",
            "api_key": self.api,
            "departure_id": origin,
            "arrival_id": destination,
            "outbound_date": departure_date,
            "type": "1" if return_date else "2",  # 1 for round trip; 2 for one way
            "show_hidden": "true",
            "travel_class": travel_class
        }
        if return_date:
            params["return_date"] = return_date
        if token:
            params["departure_token"] = token


        response = requests.get(url, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error: {response.status_code} - {response.text}")
            return None

    def compare_stops(self):
        # Calculate median price by number of stops and travel class
        out = self.df_all_flights.groupby(['Stops', 'Travel Class'])['Price'].median().unstack()
        return out


    def non_economy_cheaper_than_economy(self):
        median_price_economy = self.df_all_flights[self.df_all_flights['Travel Class'] == 'Economy']['Price'].median()
        non_economy_cheaper_than_economy = self.df_all_flights[(self.df_all_flights['Travel Class'] != 'Economy') & (self.df_all_flights['Price'] <= median_price_economy)]
        return non_economy_cheaper_than_economy

firm = '2107 Addison St, Berkeley, CA'
commuting_data = pd.DataFrame({
    'ID': [1, 2, 3],
    'method':['car','uber','car'],
    'locations':['1122 University Ave, Berkeley, CA','2010 Fifth St, Berkeley, CA','3006 San Pablo Ave, Berkeley, CA '],
    'frequency': [22, 20, 18],
    'cost_per_km':[0.1,0.2,0.3]

})

df_dynamic = pd.DataFrame({
    'method': ['bus', 'train', 'uber'],
    'distance': [10, 10, 10],
    'cost_per_km': [0.1, 0.2, 0.7]
})
BusinessCommutingAnalyzer(commuting_data,google_maps_api_key,oil_price_api,firm,df_dynamic).calculate_current_costs_and_emissions()

class BusinessCommutingAnalyzer:
    def __init__(self, commuting_data,google_api,oil_price_api,firm_location,df_dynamic):
        self.commuting_data = commuting_data
        #self.carbon_data = carbon_data
        self.google_maps_api_key = google_api
        self.oil_api = oil_price_api
        self.firm_location = firm_location
        self.df_dynamic = df_dynamic


        cur_people = self.commuting_data
        cur_people_location = cur_people['locations']
        #print(cur_people)

        employee_coords = [self.geocode_location(location) for location in cur_people_location]
        firm_coords = self.geocode_location(firm_location)

        if None in employee_coords or firm_coords is None:
            print("Failed to geocode all locations.")
            return None

          # Calculate distances
        distances_from_firm = [geodesic(firm_coords, coord).kilometers for coord in employee_coords]



        cur_people['distance'] = distances_from_firm
        self.commuting_data = cur_people
        print(self.commuting_data)

        #self.commuting_data['distance'] = self.calculate_distance(self.firm_location,self.commuting_data['locations'])

    def calculate_current_costs_and_emissions(self):
        total_cost = 0
        total_carbon = 0
        print(self.commuting_data)
        for index, row in self.commuting_data.iterrows():
            distance = row['distance']
            frequency = row['frequency']
            cost_per_km = row['cost_per_km']
            total_cost += distance * frequency * cost_per_km
            total_carbon += distance * frequency * cost_per_km * 0.2

        return total_cost, total_carbon




    def geocode_location(self,location):
    # (latitude, longitude) using Google Maps Geocoding API
      base_url = "https://maps.googleapis.com/maps/api/geocode/json"
      params = {
          "address": location,
          "key": self.google_maps_api_key
      }
      #print(params)
      response = requests.get(base_url, params=params)
      if response.status_code == 200:
          data = response.json()
          #print(data)
          if data['results']:
              #print(1)
              latitude = data['results'][0]['geometry']['location']['lat']
              longitude = data['results'][0]['geometry']['location']['lng']
              return (latitude, longitude)
      return None

    def get_state_code(self,coords):

      base_url = "https://maps.googleapis.com/maps/api/geocode/json"
      params = {"latlng": f"{coords[0]},{coords[1]}", "key": self.google_maps_api_key}
      response = requests.get(base_url, params=params)
      data = response.json()
      if response.status_code == 200 and data['results']:
          for component in data['results'][0]['address_components']:
              if 'administrative_area_level_1' in component['types']:
                  return component['short_name']
      return None

    def calculate_distance(self,location1, location2):
      """Calculate the distance between two geographical coordinates."""
      coords_1 = self.geocode_location(location1)
      time.sleep(10)
      coords_2 = self.geocode_location(location2)

      if coords_1 and coords_2:
          return geodesic(coords_1, coords_2).kilometers
      else:
          return None

    def get_local_gas_price(self,state_code):

      if self.oil_api:
          base_url = f"https://api.eia.gov/v2/petroleum/pri/gnd/data/?api_key={self.oil_api}&frequency=weekly&data[0]=value&facets[duoarea][]=S{state_code}&sort[0][column]=period&sort[0][direction]=desc&offset=0&length=1"
          response = requests.get(base_url)
          data = response.json()
          print(f"API response: {data}")
          if response.status_code == 200 and 'response' in data and 'data' in data['response'] and len(data['response']['data']) > 0:
              return float(data['response']['data'][0]['value'])
      print(f"Failed to retrieve gas price for state: {state_code}")
      return 4

    def stipent_individual(self,df_survey,firm_location,employee_ID, cur_stipend, num_change_days,mpg):

      cur_person = df_survey.loc[df_survey['ID'] == employee_ID,['locations','frequency']]


      state_code = self.get_state_code(self.geocode_location(cur_person['locations']))

      cur_person['cost_per_km'] = (self.get_local_gas_price(state_code)/mpg) / 1.609344

      firm_coords = self.geocode_location(firm_location)
      employee_coords = self.geocode_location(cur_person['locations'])
      distance = geodesic(firm_coords, employee_coords).kilometers
      cur_person['distance'] = distance
      #print(cur_person)

      cur_cost = cur_person['distance'].values[0] * cur_person['frequency'].values[0] * cur_person['cost_per_km'].values[0]

      dic = {}
      dic_cash = {}
      optimal = cur_cost

      for method in self.df_dynamic['method'].unique():
          temp = self.df_dynamic.loc[self.df_dynamic['method'] == method]
          if not temp.empty:
              temp_cost_new = temp['distance'].values[0] * num_change_days * temp['cost_per_km'].values[0]
              cost_original = (cur_person['frequency'].values[0] - num_change_days) * cur_person['distance'].values[0] * cur_person['cost_per_km'].values[0]
              new_cost = temp_cost_new + cost_original

              if new_cost < cur_stipend:
                  cash = (cur_stipend - new_cost) * 0.9  # This factor can be adjusted
                  dic_cash[method] = cash

              dic[method] = new_cost

              if new_cost < optimal:
                  optimal = new_cost

      return dic, dic_cash, optimal

    def get_directions(self,origin, destination, waypoints=[]):
        base_url = "https://maps.googleapis.com/maps/api/directions/json"
        params = {
            "origin": origin,
            "destination": destination,
            "waypoints": "|".join(waypoints),
            "key": self.google_maps_api_key,
            "departure_time": "now"
        }
        response = requests.get(base_url, params=params)
        data = response.json()
        if response.status_code == 200 and data['routes']:
            return data['routes'][0]
        else:
            print(f"Error: {data.get('error_message')} | Status: {data.get('status')}")
        return None

    def find_optimal_route(self,firm_location, employee_locations):
        best_route = None
        best_order = None
        min_distance = float('inf')
        min_duration = float('inf')

        # Generate all possible orders for the waypoints
        for order in permutations(employee_locations):
            for i in range(len(order)):
                waypoints = list(order[:i]) + list(order[i+1:])  # All waypoints except the final destination
                final_destination = order[i]  # The i-th location in the order is the final destination
                route = self.get_directions(firm_location, final_destination, waypoints=waypoints)

                if route:
                    total_distance = sum(leg['distance']['value'] for leg in route['legs']) / 1000  # Convert to kilometers
                    total_duration = sum(leg['duration']['value'] for leg in route['legs']) / 60  # Convert to minutes

                    if total_distance < min_distance:
                        min_distance = total_distance
                        min_duration = total_duration
                        best_route = route
                        best_order = waypoints + [final_destination]  # Append final destination at the end

        if best_route:

            return {
                "route": best_route,
                "total_distance_km": min_distance,
                "total_duration_min": min_duration,
                "optimal_order": best_order
            }
        return None


    def carpool_savings(self, df_survey, firm_location, employee_ids, cur_stipend, num_carpool_days, mpg):

      # Get the current details of each person
      firm_coords = self.geocode_location(firm_location)
      #print(1)
      cur_people = df_survey[df_survey['ID'].isin(employee_ids)]
      cur_people_location = cur_people['locations']
      #print(cur_people)

      employee_coords = [self.geocode_location(location) for location in cur_people_location]
      #employee_locations = df_survey.loc[df_survey['ID']==employee_ids,'locations']
      #print(employee_coords)
      if None in employee_coords or firm_coords is None:
          print("Failed to geocode all locations.")
          return None

        # Calculate distances
      distances_from_firm = [geodesic(firm_coords, coord).kilometers for coord in employee_coords]



      cur_people['distance'] = distances_from_firm
      # caveat
      state_code = self.get_state_code(self.geocode_location(cur_people['locations']))

      cur_people['cost_per_km'] = (self.get_local_gas_price(state_code)/mpg) / 1.609344
      cur_costs = cur_people.apply(lambda row: row['distance'] * row['frequency'] * row['cost_per_km'], axis=1)

      optimal_distance = self.find_optimal_route(firm_location, cur_people_location)['total_distance_km']
      duration = self.find_optimal_route(firm_location, cur_people_location)['total_duration_min']
      #print(optimal_distance)
      #print(duration)
      carpool_cost = min(cur_people['cost_per_km'] )
      new_cost_carpool_days = (optimal_distance*num_carpool_days*carpool_cost)

      new_cost_original_days = cur_people['distance']*cur_people['cost_per_km']*(cur_people['frequency']-num_carpool_days)
      new_cost_total = new_cost_carpool_days+new_cost_original_days
      #print(new_cost_total)
      new_carbon = duration*0.2

      net_cost = new_cost_total - cur_costs
      cash = net_cost*0.9
      return net_cost,cash,new_carbon

# newest!!!!!!!!!!!!!!!!!

class DecarbWeight:
    def __init__(self, price_weight, duration_weight,stop_weight,carbon_weight):
        self.price_weight =price_weight
        self.duration_weight = duration_weight
        self.stop_weight = stop_weight
        self.carbon_weight = carbon_weight
        if not self.verify_weight():

          raise ValueError("Weight must add up to 1")
    def verify_weight(self):
      lst = [self.price_weight,self.duration_weight,self.stop_weight,self.carbon_weight]

      total = sum(lst)
      print(total)

      return round(total,2)==1

class DecarbStepType(Enum):
    FLIGHTS = 1
    COMMUTING = 2
    ELECTRICITY = 3
DecarbStepType = Enum('DecarbStepType', ['FLIGHTS', 'COMMUTING', 'ELECTRICITY'])
class DecarbStep:
    def __init__(self, step_type, cur_cost, new_cost, cur_emissions, new_emissions, description):
        self.step_type = step_type
        self.cur_cost = cur_cost
        self.new_cost = new_cost
        self.cur_emissions = cur_emissions
        self.new_emissions = new_emissions
        self.description = description

    def compute_savings(self):
        return self.cur_cost - self.new_cost

    def compute_emissions_savings(self):
        return self.cur_emissions - self.new_emissions

    def generate_step_description(self):
        return f"Step {self.step_type.value}: {self.description}"

class FlightDecarbStep(DecarbStep):
    def __init__(self, cur_cost, new_cost, cur_emissions, new_emissions, description, num_stops):
        super().__init__(DecarbStepType.FLIGHTS, cur_cost, new_cost, cur_emissions, new_emissions, description)
        self.num_stops = num_stops

    def generate_step_description(self):
        base_description = super().generate_step_description()
        return f"{base_description}, with {self.num_stops} stop(s)"

class DecarbEngine:
    def __init__(self, commuting_data,dynamic_data, origin, destination, departure_date,firm,weights,return_date=None):

        self.GOOGLE_MAPS_API_KEY = "AIzaSyD1fbsNKLIWwHly5YcSBcuMWhYd2kTIN08"
        #self.FLIGHT_API_KEY = '7b97097f97bcea06b3c9c8b81e864da1f686069cdfba1dfd89834eec702b8f16'
        self.OIL_PRICE_API_KEY = 'jDLAcmPbuXd1CMXRjKFZMliukSgC6ujhUjnKaxOf'
        self.firm = firm
        self.dynamic = dynamic_data

        self.weights = DecarbWeight(0.4, 0.3,0.2,0.1)
        #print(self.weights)

        self.commuting_analyzer = BusinessCommutingAnalyzer(commuting_data, self.GOOGLE_MAPS_API_KEY, self.OIL_PRICE_API_KEY,self.firm,self.dynamic)
        #self.flight_analyzer = FlightDataAnalyzer(self.FLIGHT_API_KEY,self.weights, origin, destination, departure_date, return_date)
        self.steps = []



    def analyze_commuting_costs(self):
        return self.commuting_analyzer.calculate_current_costs_and_emissions()

    # def analyze_flight_costs(self):
    #    return self.flight_analyzer.get_optimal_flight(self.flight_analyzer.df_all_flights)

    # def get_return_flight_options(self):
    #    return self.flight_analyzer.get_return_tickets()

    # def compare_flight_stops(self):
    #    return self.flight_analyzer.compare_stops()

    # def non_economy_cheaper_than_economy(self):
    #    return self.flight_analyzer.non_economy_cheaper_than_economy()

    # def get_price_insights(self):
    #    return self.flight_analyzer.price_insights()

    def run_decarb_engine(self):

        savings = 0

        # commuting costs and emissions for individual
        commuting_costs, commuting_emissions = self.analyze_commuting_costs()
        commuting_step = DecarbStep(
            step_type=DecarbStepType.COMMUTING,
            cur_cost=commuting_costs,

            new_cost=self.commuting_analyzer.stipent_individual(self.commuting_analyzer.commuting_data,self.commuting_analyzer.firm_location, 1,
                                                                 50, 2,30)[2],
            cur_emissions=commuting_emissions,
            new_emissions=commuting_emissions * 0.9,  # fake num
            description="Analyze commuting costs and emissions for individual"
        )
        self.steps.append(commuting_step)
        savings += commuting_step.compute_savings()

        # commuting cost for carpool

        commuting_costs, commuting_emissions = self.analyze_commuting_costs()
        commuting_step = DecarbStep(
            step_type=DecarbStepType.COMMUTING,
            cur_cost=commuting_costs,

            new_cost = self.commuting_analyzer.carpool_savings(self.commuting_analyzer.commuting_data,self.commuting_analyzer.firm_location,
                                                                       [1,2,3], 50,2,30)[0],
            new_emissions = self.commuting_analyzer.carpool_savings(self.commuting_analyzer.commuting_data,self.commuting_analyzer.firm_location,
                                                                       [1,2,3], 50,2,30)[2],

            cur_emissions=commuting_emissions,

            description="Analyze commuting costs and emissions for carpool"
        )
        self.steps.append(commuting_step)
        savings += commuting_step.compute_savings()






      #flight costs
        # optimal_flight = self.analyze_flight_costs()
        # print(optimal_flight)
        # flight_savings = optimal_flight['Price'].iloc[0]
        # flight_emissions = optimal_flight['Carbon Emissions'].iloc[0]
        # flight_step = FlightDecarbStep(
        #     step_type=DecarbStepType.FLIGHTS,
        #     cur_cost=flight_savings * 1.1,  # fake num
        #     new_cost=flight_savings,
        #     cur_emissions=flight_emissions * 1.1,  # fake num
        #     new_emissions=flight_emissions,
        #     description="Analyze flight costs and emissions",
        #     num_stops=optimal_flight['Stops'].iloc[0]
        # )
        # self.steps.append(flight_step)
        # savings += flight_step.compute_savings()




        # return flight
        # return_flight = self.get_return_flight_options(self.weights)
        # return_flight_savings = return_flight['Price'].iloc[0]
        # return_flight_emissions = return_flight['Carbon Emissions'].iloc[0]
        # return_flight_step = FlightDecarbStep(
        #     step_type=DecarbStepType.FLIGHTS,
        #     cur_cost=return_flight_savings * 1.1, # fake
        #     new_cost=return_flight_savings,
        #     cur_emissions=return_flight_emissions * 1.1, # fake
        #     new_emissions=return_flight_emissions,
        #     description="Analyze return flight costs and emissions",
        #     num_stops=return_flight['Stops'].iloc[0]
        # )
        # self.steps.append(return_flight_step)
        # savings += return_flight_step.compute_savings()



        return self.steps

origin = "LAX"
destination = "JFK"
departure_date = "2024-07-01"
return_date = "2024-07-10"
firm = '2107 Addison St, Berkeley, CA'
commuting_data = pd.DataFrame({
    'ID': [1, 2, 3],
    'method':['car','uber','car'],
    'locations':['1122 University Ave, Berkeley, CA','2010 Fifth St, Berkeley, CA','3006 San Pablo Ave, Berkeley, CA '],
    'frequency': [22, 20, 18],
    'cost_per_km':[0.1,0.2,0.3]

})

df_dynamic = pd.DataFrame({
    'method': ['bus', 'train', 'uber'],
    'distance': [10, 10, 10],
    'cost_per_km': [0.1, 0.2, 0.7]
})

weights = {
    "price": 0.4,
    "duration": 0.3,
    "stops": 0.2,
    "carbon": 0.1
}
decarb_engine = DecarbEngine(commuting_data, df_dynamic,origin, destination, departure_date, firm, weights,return_date)
decarb_steps = decarb_engine.run_decarb_engine()

for step in decarb_steps:
    print(step.generate_step_description())
    print(f"Savings: ${step.compute_savings()}")
    print(f"Emissions Savings: {step.compute_emissions_savings()} kg CO2\n")



#elctricity rec

class ElectricityBillAnalyzer:
    def __init__(self, providers):
        self.providers = providers

    def analyze_bill(self, bill):
        location = bill['location']
        total_consumption_kwh = bill['total_consumption_kwh']
        current_cost_per_kwh = bill['total_cost'] / total_consumption_kwh

        # Filter providers by location
        local_providers = [p for p in self.providers if p['location'] == location]

        # Compare providers
        comparisons = []
        for provider in local_providers:
            new_cost = provider['cost_per_kwh'] * total_consumption_kwh
            cost_savings = (current_cost_per_kwh - provider['cost_per_kwh']) * total_consumption_kwh
            new_carbon = provider['carbon_per_kwh'] * total_consumption_kwh
            carbon_savings = (current_cost_per_kwh - provider['carbon_per_kwh']) * total_consumption_kwh
            comparisons.append({
                'provider': provider['name'],
                'new_cost': new_cost,
                'cost_savings': cost_savings,
                'new_carbon': new_carbon,
                'carbon_savings': carbon_savings
            })

        return comparisons
    #def region_finder(self):


    def recommend_providers(self, bill):
        recommendations = self.analyze_bill(bill)
        recommendations.sort(key=lambda x: (x['new_cost'], x['new_carbon']))

        return recommendations

    def analyze_historical_data(self, historical_data):
        # Analyze historical data to identify consumption patterns
        total_consumption = sum(record['consumption_kwh'] for record in historical_data)
        total_cost = sum(record['cost'] for record in historical_data)
        average_consumption = total_consumption / len(historical_data)
        average_cost = total_cost / len(historical_data)

        return {
            'total_consumption_kwh': total_consumption,
            'total_cost': total_cost,
            'average_consumption_kwh': average_consumption,
            'average_cost': average_cost
        }

    def compare_tariffs(self, current_tariff, new_tariffs):
        # Compare different tariff plans
        comparisons = []
        for tariff in new_tariffs:
            if 'peak_rate' in tariff and 'off_peak_rate' in tariff:
                peak_consumption = current_tariff['peak_consumption_kwh']
                off_peak_consumption = current_tariff['off_peak_consumption_kwh']
                new_cost = (tariff['peak_rate'] * peak_consumption) + (tariff['off_peak_rate'] * off_peak_consumption)
            else:
                new_cost = tariff['flat_rate'] * current_tariff['total_consumption_kwh']
            cost_savings = current_tariff['total_cost'] - new_cost
            comparisons.append({
                'tariff_name': tariff['name'],
                'new_cost': new_cost,
                'cost_savings': cost_savings
            })

        return comparisons

    def suggest_carbon_offsets(self, carbon_savings):
        # Suggest carbon offset programs
        offset_programs = [
            {'name': 'Program A', 'cost_per_kg_co2': 0.01},
            {'name': 'Program B', 'cost_per_kg_co2': 0.02}
        ]
        # offset gives you amt carbon saving * price of object, in this case, electricity
        suggestions = []
        for program in offset_programs:
            offset_cost = program['cost_per_kg_co2'] * carbon_savings
            suggestions.append({
                'program_name': program['name'],
                'offset_cost': offset_cost
            })

        return suggestions

    def analyze_solar_panel(self, bill, solar_capacity_kw, solar_cost_per_kw, maintenance_cost_per_year, solar_carbon_per_kwh,day, hour):
        location = bill['location']
        total_consumption_kwh = bill['total_consumption_kwh']
        current_cost_per_kwh = bill['total_cost'] / total_consumption_kwh

        annual_solar_production_kwh = solar_capacity_kw * day * hour  #hours of peak sunlight per day
        initial_solar_cost = solar_capacity_kw * solar_cost_per_kw
        annual_solar_maintenance_cost = maintenance_cost_per_year
        total_annual_savings = current_cost_per_kwh * annual_solar_production_kwh
        net_annual_savings = total_annual_savings - annual_solar_maintenance_cost
        total_savings = net_annual_savings - initial_solar_cost
        new_carbon = solar_carbon_per_kwh * annual_solar_production_kwh
        carbon_savings = current_cost_per_kwh * total_consumption_kwh - new_carbon

        return {
            'solar_capacity_kw': solar_capacity_kw,
            'initial_solar_cost': initial_solar_cost,
            'annual_solar_maintenance_cost': annual_solar_maintenance_cost,
            'annual_solar_production_kwh': annual_solar_production_kwh,
            'total_annual_savings': total_annual_savings,
            'net_annual_savings': net_annual_savings,
            'total_savings': total_savings,
            'new_carbon': new_carbon,
            'carbon_savings': carbon_savings
        }


    def notify_user(self, email, message):

        print(f"Sending email to {email} with message: {message}")

    def integrate_with_ui(self, user_input):
        # Placeholder for UI integration
        bill = user_input['bill']
        recommendations = self.recommend_providers(bill)
        return recommendations



providers = [
    {'name': 'Provider A', 'location': 'Location 1', 'cost_per_kwh': 0.15, 'carbon_per_kwh': 0.5},
    {'name': 'Provider B', 'location': 'Location 1', 'cost_per_kwh': 0.12, 'carbon_per_kwh': 0.4},
    {'name': 'Provider C', 'location': 'Location 2', 'cost_per_kwh': 0.10, 'carbon_per_kwh': 0.3},
    {'name': 'Provider D', 'location': 'Location 2', 'cost_per_kwh': 0.13, 'carbon_per_kwh': 0.2},
]

# electricity bill
electricity_bill = {
    'location': 'Location 1',
    'total_consumption_kwh': 500,
    'total_cost': 75  # Assume current provider's cost per kWh is 0.15
}

# historical data
historical_data = [
    {'consumption_kwh': 450, 'cost': 67.5},
    {'consumption_kwh': 500, 'cost': 75},
    {'consumption_kwh': 480, 'cost': 72}
]

# current tariff
current_tariff = {
    'total_consumption_kwh': 500,
    'total_cost': 75,
    'peak_consumption_kwh': 300,
    'off_peak_consumption_kwh': 200
}

# new tariffs
new_tariffs = [
    {'name': 'Tariff A', 'flat_rate': 0.14},
    {'name': 'Tariff B', 'peak_rate': 0.16, 'off_peak_rate': 0.08}
]

# Create class
analyzer = ElectricityBillAnalyzer(providers)

# Get recommendations
recommendations = analyzer.recommend_providers(electricity_bill)
print("Provider Recommendations:")
for recommendation in recommendations:
    print(recommendation)

# Analyze historical data
historical_analysis = analyzer.analyze_historical_data(historical_data)
print("\nHistorical Data Analysis:")
print(historical_analysis)

# Compare tariffs
tariff_comparisons = analyzer.compare_tariffs(current_tariff, new_tariffs)
print("\nTariff Comparisons:")
for comparison in tariff_comparisons:
    print(comparison)

# Suggest carbon offsets
carbon_savings = 200
carbon_offset_suggestions = analyzer.suggest_carbon_offsets(carbon_savings)
print("\nCarbon Offset Suggestions:")
for suggestion in carbon_offset_suggestions:
    print(suggestion)

# Notify
analyzer.notify_user("tunan_li@berkely.edu", "We found a better electricity plan for you!")

# Integrate with UI
user_input = {'bill': electricity_bill}
ui_recommendations = analyzer.integrate_with_ui(user_input)
print("\nUI Integration Recommendations:")
for recommendation in ui_recommendations:
    print(recommendation)







